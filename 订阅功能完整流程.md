# 订阅公开知识库 - 完整流程解析

## 🎯 概述

当用户在知识广场点击"+ 订阅"按钮时，会触发一个完整的前后端交互流程。

---

## 📱 前端流程

### 1. 用户点击订阅按钮

**位置**：`web/pages/Knowledge.tsx` - 知识库卡片

```tsx
<button
  className={styles.subscribeBtn}
  onClick={(e) => {
    e.stopPropagation();  // 阻止事件冒泡，不触发卡片点击
    handleSubscribe(kb.id, kb.isSubscribed);
  }}
>
  {kb.isSubscribed ? '✓ 已订阅' : '+ 订阅'}
</button>
```

**发生的事情**：
- ✅ 阻止事件冒泡（不触发卡片导航）
- ✅ 调用 `handleSubscribe(kb.id, kb.isSubscribed)`
- ✅ 传入知识库ID和当前订阅状态

---

### 2. 订阅处理函数

**代码**：`web/pages/Knowledge.tsx`

```typescript
const handleSubscribe = async (kbId: string, isSubscribed: boolean) => {
  try {
    if (isSubscribed) {
      // 如果已订阅，则取消订阅
      await kbAPI.unsubscribe(kbId);
    } else {
      // 如果未订阅，则订阅
      await kbAPI.subscribe(kbId);
    }
    // 重新加载公开知识库列表（刷新UI）
    await loadPublicKBs(activeCategory);
  } catch (error: any) {
    alert(error.message || '操作失败');
  }
};
```

**发生的事情**：
- ✅ 判断当前订阅状态
- ✅ 调用相应的API（subscribe 或 unsubscribe）
- ✅ 刷新知识库列表（更新订阅状态和订阅数）
- ✅ 错误处理（显示友好提示）

---

### 3. API 调用

**代码**：`web/lib/api.ts`

```typescript
async subscribe(kbId: string) {
  return request<{ subscribersCount: number }>(`/kb/${kbId}/subscribe`, {
    method: 'POST',
  });
}
```

**发生的事情**：
- ✅ 发送 `POST /api/kb/{kbId}/subscribe` 请求
- ✅ 自动附加 Authorization Bearer Token
- ✅ 返回新的订阅数

**HTTP 请求示例**：
```http
POST /api/kb/550e8400-e29b-41d4-a716-446655440000/subscribe
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
```

---

## 🔧 后端流程

### 1. Controller 层 - 接收请求

**代码**：`src/controllers/kb_controller.py`

```python
@router.post("/{kbId}/subscribe")
async def subscribe_to_kb(
    kbId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Subscribe to a public knowledge base."""
    service = KnowledgeBaseService(db)
    return await service.subscribe_kb(kbId, str(current_user.id))
```

**发生的事情**：
- ✅ 接收知识库ID (kbId)
- ✅ 从JWT Token中提取当前用户 (current_user)
- ✅ 获取数据库会话 (db)
- ✅ 调用 Service 层处理业务逻辑

---

### 2. Service 层 - 业务逻辑

**代码**：`src/services/kb_service.py`

```python
async def subscribe_kb(self, kb_id: str, user_id: str) -> dict:
    """Subscribe to a public knowledge base."""
    
    # 步骤1: 检查知识库是否存在且公开
    kb = await self.kb_repo.get_by_id_public(kb_id)
    if not kb:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={"error": {"code": "NOT_FOUND", "message": "Public knowledge base not found"}}
        )
    
    # 步骤2: 防止订阅自己的知识库
    if str(kb.owner_id) == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={"error": {"code": "VALIDATION_ERROR", "message": "Cannot subscribe to your own knowledge base"}}
        )
    
    # 步骤3: 执行订阅操作
    await self.subscription_repo.subscribe(user_id, kb_id)
    logger.info(f"User {user_id} subscribed to KB {kb_id}")
    
    # 步骤4: 返回更新后的订阅数
    kb = await self.kb_repo.get_by_id_public(kb_id)
    return {"subscribersCount": kb.subscribers_count}
```

**发生的事情**：
- ✅ **权限校验**：检查知识库是否公开
- ✅ **业务规则校验**：不能订阅自己的知识库
- ✅ **执行订阅**：调用 Repository 层
- ✅ **日志记录**：记录订阅操作
- ✅ **返回结果**：返回更新后的订阅数

**错误处理**：
- ❌ 知识库不存在或未公开 → 404 错误
- ❌ 订阅自己的知识库 → 400 错误

---

### 3. Repository 层 - 数据库操作

**代码**：`src/repositories/kb_subscription_repository.py`

```python
async def subscribe(self, user_id: str, kb_id: str) -> KnowledgeBaseSubscription:
    """Subscribe to a knowledge base."""
    
    # 步骤1: 检查是否已经订阅（幂等性保证）
    existing = await self.get_subscription(user_id, kb_id)
    if existing:
        return existing  # 已订阅，直接返回
    
    # 步骤2: 创建订阅记录
    subscription = KnowledgeBaseSubscription(
        user_id=user_id,
        kb_id=kb_id
    )
    self.db.add(subscription)
    
    # 步骤3: 增加知识库的订阅数
    kb = await self.db.execute(
        select(KnowledgeBase).where(KnowledgeBase.id == kb_id)
    )
    kb_obj = kb.scalar_one_or_none()
    if kb_obj:
        kb_obj.subscribers_count += 1
    
    # 步骤4: 提交事务
    await self.db.commit()
    await self.db.refresh(subscription)
    
    return subscription
```

**发生的事情**：
- ✅ **幂等性检查**：如果已订阅，直接返回（不会重复订阅）
- ✅ **创建订阅记录**：插入 `kb_subscriptions` 表
- ✅ **更新订阅数**：`knowledge_bases.subscribers_count += 1`
- ✅ **事务提交**：原子性保证数据一致性

---

## 🗄️ 数据库变化

### 订阅前

**kb_subscriptions 表**：
```
（无记录）
```

**knowledge_bases 表**：
```
id: 550e8400-e29b-41d4-a716-446655440000
name: "DeepSeek系列论文"
is_public: true
subscribers_count: 5  ← 当前订阅数
```

---

### 订阅后

**kb_subscriptions 表（新增记录）**：
```
id: f47ac10b-58cc-4372-a567-0e02b2c3d479
user_id: a1b2c3d4-e5f6-7890-abcd-ef1234567890  ← 当前用户
kb_id: 550e8400-e29b-41d4-a716-446655440000     ← 知识库
subscribed_at: 2025-10-25T10:30:00Z
last_viewed_at: null
```

**knowledge_bases 表（更新）**：
```
id: 550e8400-e29b-41d4-a716-446655440000
name: "DeepSeek系列论文"
is_public: true
subscribers_count: 6  ← 订阅数 +1
```

---

## 🔄 前端 UI 更新

### 刷新流程

```typescript
await loadPublicKBs(activeCategory);
```

**发生的事情**：
1. 重新调用 `GET /api/kb/public/list?category=工学`
2. 后端返回最新的知识库列表（包含更新的 `subscribersCount`）
3. 前端更新 `publicKbs` 状态
4. React 重新渲染卡片列表
5. 订阅按钮文字变为 "✓ 已订阅"
6. 订阅数显示更新：`5 订阅` → `6 订阅`

---

## 🔀 取消订阅流程

### 后端处理

```python
async def unsubscribe(self, user_id: str, kb_id: str) -> bool:
    """Unsubscribe from a knowledge base."""
    
    # 步骤1: 删除订阅记录
    result = await self.db.execute(
        delete(KnowledgeBaseSubscription).where(
            KnowledgeBaseSubscription.user_id == user_id,
            KnowledgeBaseSubscription.kb_id == kb_id
        )
    )
    
    # 步骤2: 减少订阅数
    if result.rowcount > 0:
        kb = await self.db.execute(
            select(KnowledgeBase).where(KnowledgeBase.id == kb_id)
        )
        kb_obj = kb.scalar_one_or_none()
        if kb_obj and kb_obj.subscribers_count > 0:
            kb_obj.subscribers_count -= 1
        
        await self.db.commit()
        return True
    return False
```

**数据库变化**：
- ✅ 删除 `kb_subscriptions` 表中的记录
- ✅ `knowledge_bases.subscribers_count -= 1`

---

## 📊 完整流程图

```
用户点击"+ 订阅"
        ↓
前端: handleSubscribe()
        ↓
前端: kbAPI.subscribe(kbId)
        ↓
HTTP: POST /api/kb/{kbId}/subscribe
        ↓
后端: Controller - subscribe_to_kb()
        ↓
后端: Service - subscribe_kb()
        ├─→ 检查知识库是否公开
        ├─→ 检查是否订阅自己的KB
        └─→ 调用 Repository
                ↓
后端: Repository - subscribe()
        ├─→ 检查是否已订阅（幂等性）
        ├─→ 创建订阅记录（kb_subscriptions）
        ├─→ 订阅数 +1（knowledge_bases）
        └─→ 提交数据库事务
                ↓
返回: { subscribersCount: 6 }
        ↓
前端: 重新加载知识库列表
        ↓
UI 更新:
  ├─→ 按钮: "+ 订阅" → "✓ 已订阅"
  ├─→ 订阅数: "5 订阅" → "6 订阅"
  └─→ 卡片状态更新
```

---

## 🔒 安全机制

### 1. 身份验证
- ✅ JWT Token 验证
- ✅ `get_current_user` 依赖注入

### 2. 权限校验
- ✅ 检查知识库是否公开（`is_public = true`）
- ✅ 防止订阅自己的知识库

### 3. 幂等性保证
- ✅ 重复订阅不会报错
- ✅ 订阅数不会重复增加

### 4. 数据一致性
- ✅ 数据库事务（ACID）
- ✅ 订阅记录和订阅数同步更新

---

## ⚡ 性能优化

### 1. 前端
- ✅ 事件冒泡阻止（不触发卡片点击）
- ✅ 批量刷新（一次API调用更新所有卡片）

### 2. 后端
- ✅ 数据库索引优化
  - `kb_subscriptions.user_id` (索引)
  - `kb_subscriptions.kb_id` (索引)
  - 唯一约束: `(user_id, kb_id)`

### 3. 数据库
- ✅ 原子性操作（单次事务）
- ✅ 条件更新（避免并发问题）

---

## 🐛 错误处理

### 前端
```typescript
catch (error: any) {
  alert(error.message || '操作失败');
}
```

### 后端错误码
| 错误码 | 场景 | HTTP状态 | 提示信息 |
|-------|------|---------|---------|
| `NOT_FOUND` | 知识库不存在/未公开 | 404 | "Public knowledge base not found" |
| `VALIDATION_ERROR` | 订阅自己的知识库 | 400 | "Cannot subscribe to your own knowledge base" |
| `CONFLICT` | 数据库唯一约束冲突 | 409 | （被幂等性处理） |

---

## 📝 日志记录

```python
logger.info(f"User {user_id} subscribed to KB {kb_id}")
```

**记录内容**：
- 用户ID
- 知识库ID
- 时间戳
- 操作类型（订阅/取消订阅）

---

## 🎯 总结

### 前端做的事情
1. ✅ 捕获用户点击
2. ✅ 阻止事件冒泡
3. ✅ 调用API
4. ✅ 刷新UI
5. ✅ 错误提示

### 后端做的事情
1. ✅ 身份验证
2. ✅ 权限校验
3. ✅ 业务规则验证
4. ✅ 数据库操作（订阅记录 + 订阅数）
5. ✅ 日志记录
6. ✅ 返回结果

### 数据库做的事情
1. ✅ 插入订阅记录（`kb_subscriptions`）
2. ✅ 更新订阅数（`knowledge_bases.subscribers_count += 1`）
3. ✅ 事务提交（保证一致性）

### 用户看到的变化
1. ✅ 按钮文字变化："+ 订阅" → "✓ 已订阅"
2. ✅ 订阅数增加："5 订阅" → "6 订阅"
3. ✅ 即时反馈（无需刷新页面）

---

**设计亮点**：
- 🎯 **用户体验**：即时反馈，无需等待
- 🔒 **安全可靠**：完整的权限校验和错误处理
- ⚡ **性能优化**：幂等性保证，数据库索引
- 🛡️ **数据一致性**：事务保证，原子操作
- 📊 **可追踪**：完整的日志记录

---

*生成时间: 2025-10-25*
*文档版本: 1.0*

