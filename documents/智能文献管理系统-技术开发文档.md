# 智能文献管理系统 - 技术开发文档

## 1. 技术架构设计

### 1.1 整体架构

```mermaid
graph TD
    A[Flutter Web/Desktop Client] --> B[API Gateway]
    B --> C[FastAPI Backend]
    C --> D[PostgreSQL Database]
    C --> E[Neo4j Graph Database]
    C --> F[Redis Cache]
    C --> G[Elasticsearch]
    C --> H[MinIO Object Storage]
    C --> I[AI Service]
    
    subgraph "Frontend Layer"
        A
    end
    
    subgraph "API Layer"
        B
    end
    
    subgraph "Backend Services"
        C
        I
    end
    
    subgraph "Data Layer"
        D
        E
        F
        G
        H
    end
```

### 1.2 技术栈选择

#### 1.2.1 后端技术栈
- **Web框架**: FastAPI 0.104+
- **数据库ORM**: SQLAlchemy 2.0+
- **异步支持**: asyncio + asyncpg
- **认证授权**: JWT + OAuth2
- **文档解析**: PyPDF2, python-docx, spaCy
- **AI集成**: OpenAI API, Transformers
- **任务队列**: Celery + Redis
- **API文档**: FastAPI自动生成Swagger

#### 1.2.2 前端技术栈
- **框架**: Flutter 3.16+
- **状态管理**: Riverpod 2.4+
- **路由管理**: go_router 12.0+
- **HTTP客户端**: dio 5.3+
- **本地存储**: shared_preferences, hive
- **UI组件**: Material Design 3
- **图表可视化**: fl_chart, graphview

#### 1.2.3 数据存储
- **关系数据库**: PostgreSQL 15+
- **图数据库**: Neo4j 5.0+
- **缓存**: Redis 7.0+
- **搜索引擎**: Elasticsearch 8.0+
- **对象存储**: MinIO (S3兼容)

### 1.3 服务架构

#### 1.3.1 微服务划分
```
├── user-service (用户服务)
├── document-service (文档服务)
├── ai-service (AI服务)
├── knowledge-graph-service (知识图谱服务)
├── collaboration-service (协作服务)
└── notification-service (通知服务)
```

#### 1.3.2 服务通信
- **同步通信**: HTTP/REST API
- **异步通信**: Redis Pub/Sub
- **文件传输**: MinIO预签名URL

## 2. 数据库设计

### 2.1 PostgreSQL关系数据库

#### 2.1.1 核心表结构

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 用户唯一标识符，系统自动生成的UUID
    email VARCHAR(255) UNIQUE NOT NULL,                               -- 用户邮箱地址，用于登录和通知，必须唯一
    phone VARCHAR(20) UNIQUE,                                         -- 用户手机号码，可选，用于辅助验证和通知
    password_hash VARCHAR(255) NOT NULL,                              -- 用户密码的哈希值，存储加密后的密码
    username VARCHAR(100) NOT NULL,                                   -- 用户显示名称，用于界面展示
    avatar_url VARCHAR(500),                                          -- 用户头像图片URL地址，可选
    role VARCHAR(20) DEFAULT 'normal' CHECK (role IN ('normal', 'premium', 'admin')), -- 用户角色：普通用户/高级用户/管理员
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'banned')), -- 用户状态：活跃/非活跃/被禁用
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                -- 用户账户创建时间
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 用户信息最后更新时间
);

-- 文档表
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 文档唯一标识符，系统自动生成的UUID
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,    -- 文档所属用户ID，关联用户表，用户删除时级联删除文档
    title VARCHAR(500) NOT NULL,                                      -- 文档标题，用于显示和搜索
    file_name VARCHAR(255) NOT NULL,                                  -- 原始文件名，保留用户上传时的文件名
    file_path VARCHAR(1000) NOT NULL,                                 -- 文件在存储系统中的路径
    file_size BIGINT NOT NULL,                                        -- 文件大小（字节），用于存储管理和限制
    file_type VARCHAR(50) NOT NULL,                                   -- 文件类型（如PDF、DOC、TXT等）
    content_text TEXT,                                                 -- 文档提取的纯文本内容，用于搜索和AI分析
    metadata JSONB,                                                    -- 文档元数据（作者、发布时间、关键词等），JSON格式存储
    tags TEXT[],                                                       -- 文档标签数组，用于分类和快速筛选
    status VARCHAR(20) DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')), -- 文档处理状态：处理中/已完成/处理失败
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                -- 文档上传时间
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 文档信息最后更新时间
);

-- 对话表
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 对话唯一标识符，系统自动生成的UUID
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,    -- 对话所属用户ID，关联用户表，用户删除时级联删除对话
    title VARCHAR(500),                                               -- 对话标题，可由用户自定义或系统自动生成
    document_ids UUID[],                                              -- 对话关联的文档ID数组，记录对话涉及的文档
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                -- 对话创建时间
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 对话最后更新时间
);

-- 消息表
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 消息唯一标识符，系统自动生成的UUID
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE, -- 消息所属对话ID，关联对话表，对话删除时级联删除消息
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant')), -- 消息发送者角色：用户/AI助手
    content TEXT NOT NULL,                                            -- 消息内容，支持文本、Markdown等格式
    metadata JSONB,                                                    -- 消息元数据（引用文档、处理时间等），JSON格式存储
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 消息发送时间
);

-- 笔记表
CREATE TABLE notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 笔记唯一标识符，系统自动生成的UUID
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,    -- 笔记所属用户ID，关联用户表，用户删除时级联删除笔记
    title VARCHAR(500) NOT NULL,                                      -- 笔记标题，用于显示和搜索
    content TEXT NOT NULL,                                            -- 笔记内容，支持富文本格式
    tags TEXT[],                                                       -- 笔记标签数组，用于分类和快速筛选
    source_type VARCHAR(50),                                          -- 笔记来源类型：对话(conversation)/文档(document)/手动创建(manual)
    source_id UUID,                                                    -- 来源对象ID，根据source_type关联对应的对话或文档
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                -- 笔记创建时间
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 笔记最后更新时间
);

-- 组织表
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 组织唯一标识符，系统自动生成的UUID
    name VARCHAR(200) NOT NULL,                                       -- 组织名称，用于显示和识别
    description TEXT,                                                  -- 组织描述信息，可选
    owner_id UUID NOT NULL REFERENCES users(id),                     -- 组织所有者用户ID，关联用户表
    settings JSONB DEFAULT '{}',                                      -- 组织设置信息，JSON格式存储（权限配置、功能开关等）
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                -- 组织创建时间
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()                 -- 组织信息最后更新时间
);

-- 组织成员表
CREATE TABLE organization_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),                    -- 成员关系唯一标识符，系统自动生成的UUID
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- 所属组织ID，关联组织表，组织删除时级联删除成员关系
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,    -- 成员用户ID，关联用户表，用户删除时级联删除成员关系
    role VARCHAR(20) DEFAULT 'member' CHECK (role IN ('owner', 'admin', 'member')), -- 成员在组织中的角色：所有者/管理员/普通成员
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),                 -- 成员加入组织的时间
    UNIQUE(organization_id, user_id)                                  -- 确保同一用户在同一组织中只能有一个成员记录
);
```

#### 2.1.2 索引设计

```sql
-- 用户表索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_role ON users(role);

-- 文档表索引
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_documents_created_at ON documents(created_at DESC);
CREATE INDEX idx_documents_tags ON documents USING GIN(tags);
CREATE INDEX idx_documents_content_text ON documents USING GIN(to_tsvector('english', content_text));

-- 对话表索引
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_created_at ON conversations(created_at DESC);

-- 消息表索引
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);

-- 笔记表索引
CREATE INDEX idx_notes_user_id ON notes(user_id);
CREATE INDEX idx_notes_tags ON notes USING GIN(tags);
CREATE INDEX idx_notes_created_at ON notes(created_at DESC);
```

### 2.2 Neo4j图数据库

#### 2.2.1 节点类型

```cypher
// 文档节点
CREATE CONSTRAINT document_id IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE;

// 实体节点
CREATE CONSTRAINT entity_id IF NOT EXISTS FOR (e:Entity) REQUIRE e.id IS UNIQUE;

// 概念节点
CREATE CONSTRAINT concept_id IF NOT EXISTS FOR (c:Concept) REQUIRE c.id IS UNIQUE;

// 作者节点
CREATE CONSTRAINT author_id IF NOT EXISTS FOR (a:Author) REQUIRE a.id IS UNIQUE;
```

#### 2.2.2 关系类型

```cypher
// 文档包含实体
(:Document)-[:CONTAINS]->(:Entity)

// 实体之间的关系
(:Entity)-[:RELATED_TO {weight: float, type: string}]->(:Entity)

// 概念层次关系
(:Concept)-[:IS_A]->(:Concept)
(:Concept)-[:PART_OF]->(:Concept)

// 作者关系
(:Author)-[:WROTE]->(:Document)
(:Author)-[:COLLABORATED_WITH]->(:Author)
```

## 3. API接口设计

### 3.1 API规范

#### 3.1.1 RESTful API设计原则
- 使用HTTP动词：GET, POST, PUT, DELETE
- 统一的URL命名规范：`/api/v1/resource`
- 统一的响应格式
- 适当的HTTP状态码

#### 3.1.2 统一响应格式

```python
from pydantic import BaseModel
from typing import Optional, Any

class APIResponse(BaseModel):
    success: bool
    message: str
    data: Optional[Any] = None
    error_code: Optional[str] = None
    timestamp: str
```

### 3.2 核心API接口

#### 3.2.1 用户认证API

```python
# 用户注册
POST /api/v1/auth/register
{
    "email": "user@example.com",
    "password": "password123",
    "username": "用户名",
    "phone": "+86138****1234"
}

# 用户登录
POST /api/v1/auth/login
{
    "email": "user@example.com",
    "password": "password123"
}

# 刷新Token
POST /api/v1/auth/refresh
{
    "refresh_token": "refresh_token_string"
}
```

#### 3.2.2 文档管理API

```python
# 上传文档
POST /api/v1/documents/upload
Content-Type: multipart/form-data
{
    "file": <file_binary>,
    "tags": ["tag1", "tag2"]
}

# 获取文档列表
GET /api/v1/documents?page=1&size=20&tags=tag1,tag2&search=keyword

# 获取文档详情
GET /api/v1/documents/{document_id}

# 删除文档
DELETE /api/v1/documents/{document_id}

# 更新文档标签
PUT /api/v1/documents/{document_id}/tags
{
    "tags": ["new_tag1", "new_tag2"]
}
```

#### 3.2.3 智能对话API

```python
# 创建对话
POST /api/v1/conversations
{
    "title": "对话标题",
    "document_ids": ["doc_id_1", "doc_id_2"]
}

# 发送消息
POST /api/v1/conversations/{conversation_id}/messages
{
    "content": "用户问题",
    "context_documents": ["doc_id_1"]
}

# 获取对话历史
GET /api/v1/conversations/{conversation_id}/messages?page=1&size=50

# 获取对话列表
GET /api/v1/conversations?page=1&size=20
```

#### 3.2.4 知识图谱API

```python
# 获取文档知识图谱
GET /api/v1/knowledge-graph/documents/{document_id}

# 获取用户知识图谱
GET /api/v1/knowledge-graph/users/{user_id}?depth=2&limit=100

# 搜索实体
GET /api/v1/knowledge-graph/entities/search?q=keyword&type=person,concept

# 获取实体关系
GET /api/v1/knowledge-graph/entities/{entity_id}/relations?depth=1
```

### 3.3 API认证与授权

#### 3.3.1 JWT Token结构

```python
# JWT Payload
{
    "user_id": "uuid",
    "email": "user@example.com",
    "role": "normal",
    "exp": 1234567890,
    "iat": 1234567890
}
```

#### 3.3.2 权限控制

```python
from enum import Enum

class Permission(Enum):
    READ_DOCUMENT = "read:document"
    WRITE_DOCUMENT = "write:document"
    DELETE_DOCUMENT = "delete:document"
    MANAGE_ORGANIZATION = "manage:organization"
    ADMIN_USER = "admin:user"

# 角色权限映射
ROLE_PERMISSIONS = {
    "normal": [Permission.READ_DOCUMENT, Permission.WRITE_DOCUMENT],
    "premium": [Permission.READ_DOCUMENT, Permission.WRITE_DOCUMENT, Permission.DELETE_DOCUMENT],
    "admin": [Permission.READ_DOCUMENT, Permission.WRITE_DOCUMENT, Permission.DELETE_DOCUMENT, 
              Permission.MANAGE_ORGANIZATION, Permission.ADMIN_USER]
}
```

## 4. 前端架构设计

### 4.1 Flutter项目结构

```
lib/
├── main.dart
├── app/
│   ├── app.dart
│   ├── routes/
│   │   ├── app_router.dart
│   │   └── route_names.dart
│   └── themes/
│       ├── app_theme.dart
│       └── color_schemes.dart
├── core/
│   ├── constants/
│   ├── errors/
│   ├── network/
│   ├── storage/
│   └── utils/
├── data/
│   ├── datasources/
│   ├── models/
│   ├── repositories/
│   └── services/
├── domain/
│   ├── entities/
│   ├── repositories/
│   └── usecases/
├── presentation/
│   ├── pages/
│   │   ├── auth/
│   │   ├── chat/
│   │   ├── documents/
│   │   ├── knowledge_graph/
│   │   ├── notes/
│   │   └── profile/
│   ├── widgets/
│   └── providers/
└── shared/
    ├── components/
    ├── extensions/
    └── mixins/
```

### 4.2 状态管理架构

#### 4.2.1 Riverpod Provider结构

```dart
// 认证状态管理
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier(ref.read(authRepositoryProvider));
});

// 文档状态管理
final documentsProvider = StateNotifierProvider<DocumentsNotifier, DocumentsState>((ref) {
  return DocumentsNotifier(ref.read(documentRepositoryProvider));
});

// 对话状态管理
final conversationProvider = StateNotifierProvider.family<ConversationNotifier, ConversationState, String>(
  (ref, conversationId) {
    return ConversationNotifier(
      conversationId,
      ref.read(chatRepositoryProvider),
    );
  },
);
```

#### 4.2.2 状态类定义

```dart
@freezed
class AuthState with _$AuthState {
  const factory AuthState({
    @Default(false) bool isLoading,
    @Default(false) bool isAuthenticated,
    User? user,
    String? token,
    String? error,
  }) = _AuthState;
}

@freezed
class DocumentsState with _$DocumentsState {
  const factory DocumentsState({
    @Default(false) bool isLoading,
    @Default([]) List<Document> documents,
    @Default(1) int currentPage,
    @Default(false) bool hasMore,
    String? error,
  }) = _DocumentsState;
}
```

### 4.3 网络层设计

#### 4.3.1 HTTP客户端配置

```dart
class ApiClient {
  late final Dio _dio;
  
  ApiClient() {
    _dio = Dio(BaseOptions(
      baseUrl: AppConfig.apiBaseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
      },
    ));
    
    _dio.interceptors.addAll([
      AuthInterceptor(),
      LoggingInterceptor(),
      ErrorInterceptor(),
    ]);
  }
}
```

#### 4.3.2 API服务层

```dart
abstract class DocumentService {
  Future<ApiResponse<List<Document>>> getDocuments({
    int page = 1,
    int size = 20,
    List<String>? tags,
    String? search,
  });
  
  Future<ApiResponse<Document>> uploadDocument(File file, {List<String>? tags});
  
  Future<ApiResponse<Document>> getDocument(String id);
  
  Future<ApiResponse<void>> deleteDocument(String id);
}
```

### 4.4 UI组件设计

#### 4.4.1 通用组件

```dart
// 自定义按钮组件
class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final ButtonType type;
  final bool isLoading;
  
  const AppButton({
    Key? key,
    required this.text,
    this.onPressed,
    this.type = ButtonType.primary,
    this.isLoading = false,
  }) : super(key: key);
}

// 文档卡片组件
class DocumentCard extends StatelessWidget {
  final Document document;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;
  
  const DocumentCard({
    Key? key,
    required this.document,
    this.onTap,
    this.onDelete,
  }) : super(key: key);
}
```

#### 4.4.2 页面组件

```dart
// 智能对话页面
class ChatPage extends ConsumerStatefulWidget {
  final String? conversationId;
  
  const ChatPage({Key? key, this.conversationId}) : super(key: key);
}

// 文档管理页面
class DocumentsPage extends ConsumerStatefulWidget {
  const DocumentsPage({Key? key}) : super(key: key);
}

// 知识图谱页面
class KnowledgeGraphPage extends ConsumerStatefulWidget {
  final String? documentId;
  
  const KnowledgeGraphPage({Key? key, this.documentId}) : super(key: key);
}
```

## 5. 部署方案

### 5.1 容器化部署

#### 5.1.1 Docker配置

```dockerfile
# 后端Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 5.1.2 Docker Compose配置

```yaml
version: '3.8'

services:
  # 后端API服务
  api:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/literature_db
      - REDIS_URL=redis://redis:6379
      - NEO4J_URI=bolt://neo4j:7687
    depends_on:
      - postgres
      - redis
      - neo4j
    volumes:
      - ./uploads:/app/uploads

  # PostgreSQL数据库
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=literature_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # Neo4j图数据库
  neo4j:
    image: neo4j:5.0
    environment:
      - NEO4J_AUTH=neo4j/password
    ports:
      - "7474:7474"
      - "7687:7687"
    volumes:
      - neo4j_data:/data

  # Elasticsearch搜索引擎
  elasticsearch:
    image: elasticsearch:8.0.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - es_data:/usr/share/elasticsearch/data

  # MinIO对象存储
  minio:
    image: minio/minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
    volumes:
      - minio_data:/data

volumes:
  postgres_data:
  redis_data:
  neo4j_data:
  es_data:
  minio_data:
```

### 5.2 Kubernetes部署

#### 5.2.1 API服务部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: literature-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: literature-api
  template:
    metadata:
      labels:
        app: literature-api
    spec:
      containers:
      - name: api
        image: literature-api:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: literature-api-service
spec:
  selector:
    app: literature-api
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
```

### 5.3 前端部署

#### 5.3.1 Web端部署

```bash
# 构建Web版本
flutter build web --release

# Nginx配置
server {
    listen 80;
    server_name literature.example.com;
    
    root /var/www/literature/web;
    index index.html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api/ {
        proxy_pass http://api-backend:8000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

#### 5.3.2 桌面端打包

```bash
# Windows
flutter build windows --release

# macOS
flutter build macos --release

# Linux
flutter build linux --release
```

## 6. 开发规范

### 6.1 代码规范

#### 6.1.1 Python代码规范

```python
# 使用Black格式化
# pyproject.toml
[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'

# 使用isort导入排序
[tool.isort]
profile = "black"
multi_line_output = 3

# 使用flake8代码检查
[tool.flake8]
max-line-length = 88
extend-ignore = ["E203", "W503"]
```

#### 6.1.2 Flutter代码规范

```yaml
# analysis_options.yaml
analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
  strong-mode:
    implicit-casts: false
    implicit-dynamic: false

linter:
  rules:
    - prefer_const_constructors
    - prefer_const_literals_to_create_immutables
    - avoid_print
    - prefer_single_quotes
    - sort_constructors_first
```

### 6.2 Git工作流

#### 6.2.1 分支策略

```
main (生产分支)
├── develop (开发分支)
│   ├── feature/user-auth (功能分支)
│   ├── feature/document-upload
│   └── feature/chat-interface
├── release/v1.0.0 (发布分支)
└── hotfix/critical-bug (热修复分支)
```

#### 6.2.2 提交规范

```bash
# 提交消息格式
<type>(<scope>): <subject>

<body>

<footer>

# 示例
feat(auth): add JWT token authentication

Implement JWT-based authentication system with refresh token support.
Add middleware for token validation and user context injection.

Closes #123
```

### 6.3 测试规范

#### 6.3.1 后端测试

```python
# 单元测试示例
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_user():
    response = client.post(
        "/api/v1/users/",
        json={"email": "test@example.com", "password": "testpass123"}
    )
    assert response.status_code == 201
    assert response.json()["email"] == "test@example.com"

# 集成测试
@pytest.mark.asyncio
async def test_document_upload_flow():
    # 测试完整的文档上传流程
    pass
```

#### 6.3.2 前端测试

```dart
// 单元测试
import 'package:flutter_test/flutter_test.dart';
import 'package:literature_app/domain/entities/document.dart';

void main() {
  group('Document Entity Tests', () {
    test('should create document with valid data', () {
      final document = Document(
        id: '123',
        title: 'Test Document',
        fileName: 'test.pdf',
      );
      
      expect(document.id, '123');
      expect(document.title, 'Test Document');
    });
  });
}

// Widget测试
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:literature_app/presentation/widgets/document_card.dart';

void main() {
  testWidgets('DocumentCard displays document information', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: DocumentCard(
          document: Document(
            id: '1',
            title: 'Test Document',
            fileName: 'test.pdf',
          ),
        ),
      ),
    );
    
    expect(find.text('Test Document'), findsOneWidget);
  });
}
```

## 7. 项目管理

### 7.1 开发环境配置

#### 7.1.1 后端环境

```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# 安装依赖
pip install -r requirements.txt

# 环境变量配置
cp .env.example .env

# 数据库迁移
alembic upgrade head

# 启动开发服务器
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

#### 7.1.2 前端环境

```bash
# 检查Flutter环境
flutter doctor

# 获取依赖
flutter pub get

# 代码生成
flutter packages pub run build_runner build

# 启动开发服务器
flutter run -d chrome  # Web
flutter run -d windows # Windows桌面
```

### 7.2 CI/CD流程

#### 7.2.1 GitHub Actions配置

```yaml
# .github/workflows/backend.yml
name: Backend CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      run: |
        pytest --cov=app tests/
    
    - name: Build Docker image
      if: github.ref == 'refs/heads/main'
      run: |
        docker build -t literature-api:latest .
```

```yaml
# .github/workflows/frontend.yml
name: Frontend CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Install dependencies
      run: flutter pub get
    
    - name: Run tests
      run: flutter test
    
    - name: Build web
      if: github.ref == 'refs/heads/main'
      run: flutter build web --release
    
    - name: Deploy to staging
      if: github.ref == 'refs/heads/develop'
      run: |
        # 部署到测试环境
        echo "Deploy to staging"
```

### 7.3 监控与日志

#### 7.3.1 应用监控

```python
# 集成Prometheus监控
from prometheus_client import Counter, Histogram, generate_latest

# 定义指标
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')

# 中间件
@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time
    
    REQUEST_COUNT.labels(method=request.method, endpoint=request.url.path).inc()
    REQUEST_DURATION.observe(duration)
    
    return response
```

#### 7.3.2 日志配置

```python
# 结构化日志配置
import structlog
from structlog.stdlib import LoggerFactory

structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)
```

---

**文档版本**: v1.0  
**创建日期**: 2025年9月  
**最后更新**: 2025年9月  
