# æ”¶è—æ¨¡å—é‡æ„æ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚åˆ†æ

### æ ¸å¿ƒåŠŸèƒ½
1. **çŸ¥è¯†åº“æ”¶è—**
   - è®¢é˜…çš„çŸ¥è¯†åº“è‡ªåŠ¨æ·»åŠ åˆ°æ”¶è—
   - å¯ä»¥å•ç‹¬æ”¶è—æœªè®¢é˜…çš„çŸ¥è¯†åº“ï¼ˆå¦‚æœæœ‰æŸ¥çœ‹æƒé™ï¼‰
   - å–æ¶ˆè®¢é˜…æ—¶ï¼Œæ”¶è—ä¿ç•™ï¼ˆç”¨æˆ·å¯é€‰æ‹©æ˜¯å¦å–æ¶ˆæ”¶è—ï¼‰

2. **æ–‡æ¡£æ”¶è—**
   - åœ¨æ–‡æ¡£é¢„è§ˆé¡µé¢æ·»åŠ æ”¶è—æŒ‰é’®
   - æ”¶è—æŒ‰é’®ä½ç½®ï¼šå…³é—­é¢„è§ˆæŒ‰é’®æ—è¾¹
   - åªèƒ½æ”¶è—å½“å‰èƒ½è®¿é—®çš„çŸ¥è¯†åº“ä¸­çš„æ–‡æ¡£

3. **æ”¶è—å±•ç¤º**
   - ä¾§è¾¹æ  Favorites é¡µé¢å±•ç¤ºæ”¶è—åˆ—è¡¨
   - åˆ†ä¸¤ä¸ª Tabï¼šæ”¶è—çš„çŸ¥è¯†åº“ã€æ”¶è—çš„æ–‡æ¡£
   - æ”¯æŒå–æ¶ˆæ”¶è—æ“ä½œ

---

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### æ–¹æ¡ˆï¼šç»Ÿä¸€æ”¶è—è¡¨è®¾è®¡

```sql
-- æ”¶è—è¡¨ï¼ˆç»Ÿä¸€ç®¡ç†çŸ¥è¯†åº“å’Œæ–‡æ¡£æ”¶è—ï¼‰
CREATE TABLE favorites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    item_type VARCHAR(20) NOT NULL,  -- 'knowledge_base' æˆ– 'document'
    item_id UUID NOT NULL,           -- çŸ¥è¯†åº“IDæˆ–æ–‡æ¡£ID
    source VARCHAR(20),               -- 'subscription' è¡¨ç¤ºæ¥è‡ªè®¢é˜…è‡ªåŠ¨æ”¶è—ï¼Œ'manual' è¡¨ç¤ºæ‰‹åŠ¨æ”¶è—
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- è”åˆå”¯ä¸€çº¦æŸï¼šä¸€ä¸ªç”¨æˆ·å¯¹åŒä¸€é¡¹ç›®åªèƒ½æ”¶è—ä¸€æ¬¡
    CONSTRAINT uq_user_item UNIQUE (user_id, item_type, item_id)
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_favorites_user_type ON favorites(user_id, item_type);
CREATE INDEX idx_favorites_created ON favorites(created_at DESC);
```

### ä¸ºä»€ä¹ˆé€‰æ‹©ç»Ÿä¸€è¡¨ï¼Ÿ
âœ… ä¼˜ç‚¹ï¼š
- ç®€åŒ–æŸ¥è¯¢é€»è¾‘ï¼Œä¸€ä¸ªæ¥å£è·å–æ‰€æœ‰æ”¶è—
- æ˜“äºæ‰©å±•ï¼ˆæœªæ¥å¯ä»¥æ”¶è—å…¶ä»–ç±»å‹ï¼‰
- å‡å°‘è¡¨æ•°é‡

âŒ ç¼ºç‚¹ï¼š
- éœ€è¦å…³è”æŸ¥è¯¢è·å–è¯¦ç»†ä¿¡æ¯

---

## ğŸ”§ åç«¯å®ç°

### 1. æ•°æ®æ¨¡å‹

**æ–‡ä»¶**: `src/models/favorite.py`

```python
"""Favorite database model."""
from sqlalchemy import Column, String, DateTime, ForeignKey, UniqueConstraint, Index
from sqlalchemy.dialects.postgresql import UUID
from config.database import Base
from datetime import datetime
import uuid

class Favorite(Base):
    """Favorite model - unified table for KB and document favorites."""
    __tablename__ = "favorites"
    
    ITEM_TYPE_KB = "knowledge_base"
    ITEM_TYPE_DOC = "document"
    
    SOURCE_SUBSCRIPTION = "subscription"
    SOURCE_MANUAL = "manual"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    item_type = Column(String(20), nullable=False)  # 'knowledge_base' or 'document'
    item_id = Column(UUID(as_uuid=True), nullable=False)
    source = Column(String(20), nullable=True)  # 'subscription' or 'manual'
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    __table_args__ = (
        UniqueConstraint('user_id', 'item_type', 'item_id', name='uq_user_item_favorite'),
        Index('idx_favorites_user_type', 'user_id', 'item_type'),
    )
    
    def to_dict(self):
        """Convert to dictionary."""
        return {
            "id": str(self.id),
            "userId": str(self.user_id),
            "itemType": self.item_type,
            "itemId": str(self.item_id),
            "source": self.source,
            "createdAt": self.created_at.isoformat(),
        }
```

---

### 2. Repository å±‚

**æ–‡ä»¶**: `src/repositories/favorite_repository.py`

```python
"""Favorite repository for database operations."""
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete, func, or_
from sqlalchemy.orm import selectinload
from typing import Optional, List, Tuple
from models.favorite import Favorite
from models.knowledge_base import KnowledgeBase
from models.document import Document
from datetime import datetime

class FavoriteRepository:
    """Repository for Favorite model."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def add_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str,
        source: str = Favorite.SOURCE_MANUAL
    ) -> Favorite:
        """Add a favorite (idempotent)."""
        # Check if already exists
        existing = await self.get_favorite(user_id, item_type, item_id)
        if existing:
            return existing
        
        favorite = Favorite(
            user_id=user_id,
            item_type=item_type,
            item_id=item_id,
            source=source
        )
        self.db.add(favorite)
        await self.db.commit()
        await self.db.refresh(favorite)
        return favorite
    
    async def remove_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> bool:
        """Remove a favorite."""
        result = await self.db.execute(
            delete(Favorite).where(
                Favorite.user_id == user_id,
                Favorite.item_type == item_type,
                Favorite.item_id == item_id
            )
        )
        await self.db.commit()
        return result.rowcount > 0
    
    async def get_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> Optional[Favorite]:
        """Get a specific favorite."""
        result = await self.db.execute(
            select(Favorite).where(
                Favorite.user_id == user_id,
                Favorite.item_type == item_type,
                Favorite.item_id == item_id
            )
        )
        return result.scalar_one_or_none()
    
    async def list_kb_favorites(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[KnowledgeBase], int]:
        """List favorite knowledge bases with details."""
        # Count total
        count_stmt = select(func.count()).select_from(
            select(Favorite)
            .where(
                Favorite.user_id == user_id,
                Favorite.item_type == Favorite.ITEM_TYPE_KB
            )
            .subquery()
        )
        total = (await self.db.execute(count_stmt)).scalar()
        
        # Get favorites with KB details
        stmt = (
            select(KnowledgeBase)
            .join(
                Favorite,
                (Favorite.item_id == KnowledgeBase.id) &
                (Favorite.item_type == Favorite.ITEM_TYPE_KB)
            )
            .where(Favorite.user_id == user_id)
            .order_by(Favorite.created_at.desc())
            .limit(page_size)
            .offset((page - 1) * page_size)
        )
        
        result = await self.db.execute(stmt)
        kbs = result.scalars().all()
        
        return list(kbs), total or 0
    
    async def list_doc_favorites(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[Document], int]:
        """List favorite documents with details."""
        # Count total
        count_stmt = select(func.count()).select_from(
            select(Favorite)
            .where(
                Favorite.user_id == user_id,
                Favorite.item_type == Favorite.ITEM_TYPE_DOC
            )
            .subquery()
        )
        total = (await self.db.execute(count_stmt)).scalar()
        
        # Get favorites with document details
        stmt = (
            select(Document)
            .join(
                Favorite,
                (Favorite.item_id == Document.id) &
                (Favorite.item_type == Favorite.ITEM_TYPE_DOC)
            )
            .where(Favorite.user_id == user_id)
            .order_by(Favorite.created_at.desc())
            .limit(page_size)
            .offset((page - 1) * page_size)
        )
        
        result = await self.db.execute(stmt)
        docs = result.scalars().all()
        
        return list(docs), total or 0
    
    async def check_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> bool:
        """Check if an item is favorited."""
        favorite = await self.get_favorite(user_id, item_type, item_id)
        return favorite is not None
```

---

### 3. Service å±‚

**æ–‡ä»¶**: `src/services/favorite_service.py`

```python
"""Favorite service business logic."""
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import HTTPException, status
from repositories.favorite_repository import FavoriteRepository
from repositories.kb_repository import KnowledgeBaseRepository
from repositories.document_repository import DocumentRepository
from models.favorite import Favorite
from typing import List, Tuple
import logging

logger = logging.getLogger(__name__)

class FavoriteService:
    """Service for favorite operations."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.favorite_repo = FavoriteRepository(db)
        self.kb_repo = KnowledgeBaseRepository(db)
        self.doc_repo = DocumentRepository(db)
    
    async def favorite_kb(
        self,
        kb_id: str,
        user_id: str,
        source: str = Favorite.SOURCE_MANUAL
    ) -> dict:
        """Favorite a knowledge base."""
        # Verify KB exists and user has access (owned or public)
        kb = await self.kb_repo.get_by_id(kb_id, user_id)
        if not kb:
            kb = await self.kb_repo.get_by_id_public(kb_id)
            if not kb:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail={"error": {"code": "NOT_FOUND", "message": "Knowledge base not found or not accessible"}}
                )
        
        await self.favorite_repo.add_favorite(
            user_id,
            Favorite.ITEM_TYPE_KB,
            kb_id,
            source
        )
        logger.info(f"User {user_id} favorited KB {kb_id} (source: {source})")
        return {"success": True}
    
    async def unfavorite_kb(self, kb_id: str, user_id: str) -> dict:
        """Unfavorite a knowledge base."""
        success = await self.favorite_repo.remove_favorite(
            user_id,
            Favorite.ITEM_TYPE_KB,
            kb_id
        )
        if success:
            logger.info(f"User {user_id} unfavorited KB {kb_id}")
        return {"success": success}
    
    async def favorite_document(
        self,
        doc_id: str,
        kb_id: str,
        user_id: str
    ) -> dict:
        """Favorite a document."""
        # Verify document exists and user has access to the KB
        kb = await self.kb_repo.get_by_id(kb_id, user_id)
        if not kb:
            kb = await self.kb_repo.get_by_id_public(kb_id)
            if not kb:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail={"error": {"code": "NOT_FOUND", "message": "Knowledge base not found or not accessible"}}
                )
        
        # Verify document exists in this KB
        doc = await self.doc_repo.get_by_id(doc_id, kb_id)
        if not doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"error": {"code": "NOT_FOUND", "message": "Document not found"}}
            )
        
        await self.favorite_repo.add_favorite(
            user_id,
            Favorite.ITEM_TYPE_DOC,
            doc_id
        )
        logger.info(f"User {user_id} favorited document {doc_id}")
        return {"success": True}
    
    async def unfavorite_document(self, doc_id: str, user_id: str) -> dict:
        """Unfavorite a document."""
        success = await self.favorite_repo.remove_favorite(
            user_id,
            Favorite.ITEM_TYPE_DOC,
            doc_id
        )
        if success:
            logger.info(f"User {user_id} unfavorited document {doc_id}")
        return {"success": success}
    
    async def list_favorite_kbs(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[dict], int]:
        """List favorite knowledge bases."""
        kbs, total = await self.favorite_repo.list_kb_favorites(user_id, page, page_size)
        return [kb.to_dict(include_owner=True) for kb in kbs], total
    
    async def list_favorite_docs(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[dict], int]:
        """List favorite documents with KB info."""
        docs, total = await self.favorite_repo.list_doc_favorites(user_id, page, page_size)
        
        # Enrich with KB info
        result = []
        for doc in docs:
            doc_dict = doc.to_dict()
            # Get KB info
            kb = await self.db.get(KnowledgeBase, doc.kb_id)
            if kb:
                doc_dict["kbName"] = kb.name
                doc_dict["kbAvatar"] = kb.avatar or "/kb.png"
            result.append(doc_dict)
        
        return result, total
    
    async def check_favorites(
        self,
        user_id: str,
        items: List[dict]
    ) -> dict:
        """Batch check if items are favorited."""
        result = {}
        for item in items:
            item_type = item.get("type")
            item_id = item.get("id")
            if item_type and item_id:
                is_favorited = await self.favorite_repo.check_favorite(
                    user_id,
                    item_type,
                    item_id
                )
                result[f"{item_type}:{item_id}"] = is_favorited
        return result
```

---

### 4. Controller å±‚

**æ–‡ä»¶**: `src/controllers/favorite_controller.py`

```python
"""Favorite API endpoints."""
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from config.database import get_db
from middlewares.auth import get_current_user
from models.user import User
from services.favorite_service import FavoriteService

router = APIRouter(prefix="/favorites", tags=["Favorites"])

# ============ Knowledge Base Favorites ============

@router.post("/kb/{kbId}")
async def favorite_knowledge_base(
    kbId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Favorite a knowledge base."""
    service = FavoriteService(db)
    return await service.favorite_kb(kbId, str(current_user.id))

@router.delete("/kb/{kbId}")
async def unfavorite_knowledge_base(
    kbId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unfavorite a knowledge base."""
    service = FavoriteService(db)
    return await service.unfavorite_kb(kbId, str(current_user.id))

@router.get("/kb")
async def list_favorite_knowledge_bases(
    page: int = Query(1, ge=1),
    pageSize: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List favorite knowledge bases."""
    service = FavoriteService(db)
    items, total = await service.list_favorite_kbs(str(current_user.id), page, pageSize)
    return {
        "total": total,
        "page": page,
        "pageSize": pageSize,
        "items": items
    }

# ============ Document Favorites ============

@router.post("/document/{docId}")
async def favorite_document(
    docId: str,
    kbId: str = Query(...),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Favorite a document."""
    service = FavoriteService(db)
    return await service.favorite_document(docId, kbId, str(current_user.id))

@router.delete("/document/{docId}")
async def unfavorite_document(
    docId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unfavorite a document."""
    service = FavoriteService(db)
    return await service.unfavorite_document(docId, str(current_user.id))

@router.get("/document")
async def list_favorite_documents(
    page: int = Query(1, ge=1),
    pageSize: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List favorite documents."""
    service = FavoriteService(db)
    items, total = await service.list_favorite_docs(str(current_user.id), page, pageSize)
    return {
        "total": total,
        "page": page,
        "pageSize": pageSize,
        "items": items
    }

# ============ Batch Check ============

@router.post("/check")
async def check_favorites(
    request: dict,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Batch check if items are favorited."""
    service = FavoriteService(db)
    items = request.get("items", [])
    return await service.check_favorites(str(current_user.id), items)
```

---

### 5. é›†æˆåˆ°è®¢é˜…æµç¨‹

**ä¿®æ”¹**: `src/services/kb_service.py`

```python
async def subscribe_kb(self, kb_id: str, user_id: str) -> dict:
    """Subscribe to a public knowledge base."""
    # ... existing validation code ...
    
    # Subscribe
    await self.subscription_repo.subscribe(user_id, kb_id)
    logger.info(f"User {user_id} subscribed to KB {kb_id}")
    
    # Auto-favorite when subscribing
    from services.favorite_service import FavoriteService
    favorite_service = FavoriteService(self.db)
    try:
        await favorite_service.favorite_kb(
            kb_id,
            user_id,
            source="subscription"  # Mark as from subscription
        )
    except Exception as e:
        logger.warning(f"Failed to auto-favorite KB {kb_id}: {e}")
    
    # Return updated count
    kb = await self.kb_repo.get_by_id_public(kb_id)
    return {"subscribersCount": kb.subscribers_count}
```

---

## ğŸ¨ å‰ç«¯å®ç°

### 1. API å±‚

**æ–‡ä»¶**: `web/lib/api.ts`

```typescript
// æ”¶è—ç›¸å…³ API
export const favoriteAPI = {
  /**
   * æ”¶è—çŸ¥è¯†åº“
   */
  async favoriteKB(kbId: string) {
    return request<{ success: boolean }>(`/favorites/kb/${kbId}`, {
      method: 'POST',
    });
  },

  /**
   * å–æ¶ˆæ”¶è—çŸ¥è¯†åº“
   */
  async unfavoriteKB(kbId: string) {
    return request<{ success: boolean }>(`/favorites/kb/${kbId}`, {
      method: 'DELETE',
    });
  },

  /**
   * è·å–æ”¶è—çš„çŸ¥è¯†åº“åˆ—è¡¨
   */
  async listFavoriteKBs(page: number = 1, pageSize: number = 20) {
    const params = new URLSearchParams({ page: page.toString(), pageSize: pageSize.toString() });
    return request<{ total: number; page: number; pageSize: number; items: any[] }>(
      `/favorites/kb?${params}`,
      { method: 'GET' }
    );
  },

  /**
   * æ”¶è—æ–‡æ¡£
   */
  async favoriteDocument(docId: string, kbId: string) {
    const params = new URLSearchParams({ kbId });
    return request<{ success: boolean }>(`/favorites/document/${docId}?${params}`, {
      method: 'POST',
    });
  },

  /**
   * å–æ¶ˆæ”¶è—æ–‡æ¡£
   */
  async unfavoriteDocument(docId: string) {
    return request<{ success: boolean }>(`/favorites/document/${docId}`, {
      method: 'DELETE',
    });
  },

  /**
   * è·å–æ”¶è—çš„æ–‡æ¡£åˆ—è¡¨
   */
  async listFavoriteDocuments(page: number = 1, pageSize: number = 20) {
    const params = new URLSearchParams({ page: page.toString(), pageSize: pageSize.toString() });
    return request<{ total: number; page: number; pageSize: number; items: any[] }>(
      `/favorites/document?${params}`,
      { method: 'GET' }
    );
  },

  /**
   * æ‰¹é‡æ£€æŸ¥æ”¶è—çŠ¶æ€
   */
  async checkFavorites(items: Array<{ type: string; id: string }>) {
    return request<{ [key: string]: boolean }>('/favorites/check', {
      method: 'POST',
      body: JSON.stringify({ items }),
    });
  },
};
```

---

### 2. Favorites é¡µé¢é‡æ„

**æ–‡ä»¶**: `web/pages/Favorites.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import { Database, FileText, Trash2 } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import Sidebar from '@/components/Sidebar/Sidebar';
import { favoriteAPI } from '@/lib/api';
import { useToast } from '@/hooks/useToast';
import styles from './Favorites.module.css';

type TabType = 'kb' | 'doc';

export default function Favorites() {
  const navigate = useNavigate();
  const toast = useToast();
  const [activeTab, setActiveTab] = useState<TabType>('kb');
  const [favoriteKBs, setFavoriteKBs] = useState<any[]>([]);
  const [favoriteDocs, setFavoriteDocs] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadFavorites();
  }, [activeTab]);

  const loadFavorites = async () => {
    setLoading(true);
    try {
      if (activeTab === 'kb') {
        const response = await favoriteAPI.listFavoriteKBs();
        setFavoriteKBs(response.items);
      } else {
        const response = await favoriteAPI.listFavoriteDocuments();
        setFavoriteDocs(response.items);
      }
    } catch (error) {
      console.error('Failed to load favorites:', error);
      toast.error('åŠ è½½æ”¶è—å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  const handleUnfavoriteKB = async (kbId: string) => {
    try {
      await favoriteAPI.unfavoriteKB(kbId);
      toast.success('å·²å–æ¶ˆæ”¶è—');
      loadFavorites();
    } catch (error: any) {
      toast.error(error.message || 'æ“ä½œå¤±è´¥');
    }
  };

  const handleUnfavoriteDoc = async (docId: string) => {
    try {
      await favoriteAPI.unfavoriteDocument(docId);
      toast.success('å·²å–æ¶ˆæ”¶è—');
      loadFavorites();
    } catch (error: any) {
      toast.error(error.message || 'æ“ä½œå¤±è´¥');
    }
  };

  return (
    <div className={styles.page}>
      <Sidebar />
      
      <div className={styles.main}>
        <h1 className={styles.title}>æˆ‘çš„æ”¶è—</h1>

        <div className={styles.tabs}>
          <button
            className={`${styles.tab} ${activeTab === 'kb' ? styles.tabActive : ''}`}
            onClick={() => setActiveTab('kb')}
          >
            <Database size={16} />
            æ”¶è—çš„çŸ¥è¯†åº“
          </button>
          <button
            className={`${styles.tab} ${activeTab === 'doc' ? styles.tabActive : ''}`}
            onClick={() => setActiveTab('doc')}
          >
            <FileText size={16} />
            æ”¶è—çš„æ–‡æ¡£
          </button>
        </div>

        {loading ? (
          <div className={styles.loading}>åŠ è½½ä¸­...</div>
        ) : (
          <div className={styles.content}>
            {activeTab === 'kb' ? (
              favoriteKBs.length === 0 ? (
                <div className={styles.empty}>
                  <Database size={48} />
                  <p>è¿˜æ²¡æœ‰æ”¶è—ä»»ä½•çŸ¥è¯†åº“</p>
                </div>
              ) : (
                <div className={styles.grid}>
                  {favoriteKBs.map((kb) => (
                    <div key={kb.id} className={styles.card}>
                      <img src={kb.avatar} alt={kb.name} className={styles.avatar} />
                      <div className={styles.cardBody}>
                        <h3 className={styles.cardTitle}>{kb.name}</h3>
                        <p className={styles.cardDesc}>{kb.description || 'æš‚æ— æè¿°'}</p>
                        <div className={styles.cardActions}>
                          <button
                            className={styles.btnView}
                            onClick={() => navigate(`/knowledge/${kb.id}`)}
                          >
                            æŸ¥çœ‹
                          </button>
                          <button
                            className={styles.btnDelete}
                            onClick={() => handleUnfavoriteKB(kb.id)}
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )
            ) : (
              favoriteDocs.length === 0 ? (
                <div className={styles.empty}>
                  <FileText size={48} />
                  <p>è¿˜æ²¡æœ‰æ”¶è—ä»»ä½•æ–‡æ¡£</p>
                </div>
              ) : (
                <div className={styles.list}>
                  {favoriteDocs.map((doc) => (
                    <div key={doc.id} className={styles.docItem}>
                      <FileText size={20} />
                      <div className={styles.docInfo}>
                        <div className={styles.docName}>{doc.name}</div>
                        <div className={styles.docKb}>æ¥è‡ª: {doc.kbName}</div>
                      </div>
                      <button
                        className={styles.btnDelete}
                        onClick={() => handleUnfavoriteDoc(doc.id)}
                      >
                        <Trash2 size={14} />
                      </button>
                    </div>
                  ))}
                </div>
              )
            )}
          </div>
        )}
      </div>
    </div>
  );
}
```

---

### 3. æ–‡æ¡£é¢„è§ˆé¡µé¢æ·»åŠ æ”¶è—æŒ‰é’®

**ä¿®æ”¹**: `web/pages/KnowledgeDetail.tsx`

åœ¨æ–‡æ¡£é¢„è§ˆåŒºåŸŸæ·»åŠ æ”¶è—æŒ‰é’®ï¼ˆå…³é—­é¢„è§ˆæŒ‰é’®æ—è¾¹ï¼‰ï¼š

```typescript
<div className={styles.previewHeader}>
  <FileText size={18} />
  <span className={styles.previewTitle}>{selectedDoc.name}</span>
  <div className={styles.previewActions}>
    <button
      className={`${styles.iconBtn} ${docIsFavorited ? styles.favorited : ''}`}
      onClick={handleToggleFavoriteDoc}
      title={docIsFavorited ? 'å–æ¶ˆæ”¶è—' : 'æ”¶è—æ–‡æ¡£'}
    >
      <Star size={16} fill={docIsFavorited ? 'currentColor' : 'none'} />
    </button>
    <button
      className={styles.iconBtn}
      onClick={() => setSelectedDoc(null)}
      title="å…³é—­é¢„è§ˆ"
    >
      <X size={18} />
    </button>
  </div>
</div>
```

---

## ğŸ“Š æ•°æ®æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç”¨æˆ·è®¢é˜…çŸ¥è¯†åº“                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. åˆ›å»ºè®¢é˜…è®°å½• (kb_subscriptions)      â”‚
â”‚  2. subscribers_count += 1              â”‚
â”‚  3. è‡ªåŠ¨åˆ›å»ºæ”¶è—è®°å½• (favorites)         â”‚
â”‚     - source: "subscription"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç”¨æˆ·å–æ¶ˆè®¢é˜…                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. åˆ é™¤è®¢é˜…è®°å½•                         â”‚
â”‚  2. subscribers_count -= 1              â”‚
â”‚  3. æ”¶è—è®°å½•ä¿ç•™ (ç”¨æˆ·å¯æ‰‹åŠ¨åˆ é™¤)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç”¨æˆ·æ”¶è—æ–‡æ¡£                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. éªŒè¯ç”¨æˆ·å¯¹KBæœ‰è®¿é—®æƒé™                â”‚
â”‚  2. éªŒè¯æ–‡æ¡£å­˜åœ¨                         â”‚
â”‚  3. åˆ›å»ºæ”¶è—è®°å½•                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

### åç«¯ Backend
- [ ] åˆ›å»º `src/models/favorite.py`
- [ ] åˆ›å»º `src/repositories/favorite_repository.py`
- [ ] åˆ›å»º `src/services/favorite_service.py`
- [ ] åˆ›å»º `src/controllers/favorite_controller.py`
- [ ] åœ¨ `main.py` ä¸­æ³¨å†Œ favorite_controller
- [ ] ä¿®æ”¹ `src/services/kb_service.py` - è®¢é˜…æ—¶è‡ªåŠ¨æ”¶è—
- [ ] åˆ›å»ºæ•°æ®åº“è¿ç§»è„šæœ¬
- [ ] æµ‹è¯•æ‰€æœ‰ API ç«¯ç‚¹

### å‰ç«¯ Frontend
- [ ] åœ¨ `web/lib/api.ts` ä¸­æ·»åŠ  favoriteAPI
- [ ] é‡æ„ `web/pages/Favorites.tsx`
- [ ] åˆ›å»º `web/pages/Favorites.module.css`
- [ ] åœ¨ `web/pages/KnowledgeDetail.tsx` æ·»åŠ æ–‡æ¡£æ”¶è—æŒ‰é’®
- [ ] æ·»åŠ æ”¶è—çŠ¶æ€ç®¡ç†ï¼ˆuseStateï¼‰
- [ ] æ·»åŠ æ”¶è—/å–æ¶ˆæ”¶è—äº¤äº’
- [ ] æµ‹è¯•ç”¨æˆ·äº¤äº’æµç¨‹

### æ•°æ®åº“ Database
- [ ] åˆ›å»º `favorites` è¡¨
- [ ] æ·»åŠ ç´¢å¼•ä¼˜åŒ–
- [ ] æ•°æ®è¿ç§»æµ‹è¯•

---

## ğŸ¯ ä¼˜åŠ¿æ€»ç»“

### âœ… ç”¨æˆ·ä½“éªŒ
- è®¢é˜…çŸ¥è¯†åº“è‡ªåŠ¨æ”¶è—ï¼Œå‡å°‘æ“ä½œæ­¥éª¤
- æ–‡æ¡£æ”¶è—æ–¹ä¾¿å¿«é€Ÿè®¿é—®
- ç»Ÿä¸€çš„æ”¶è—ç®¡ç†ç•Œé¢

### âœ… æŠ€æœ¯ä¼˜åŠ¿
- ç»Ÿä¸€è¡¨è®¾è®¡ï¼Œæ˜“äºæ‰©å±•
- å¹‚ç­‰æ€§ä¿è¯ï¼Œé‡å¤æ“ä½œæ— å‰¯ä½œç”¨
- å®Œæ•´çš„æƒé™æ ¡éªŒï¼Œå®‰å…¨å¯é 

### âœ… æ€§èƒ½ä¼˜åŒ–
- åˆç†çš„ç´¢å¼•è®¾è®¡
- æ‰¹é‡æ£€æŸ¥æ¥å£å‡å°‘è¯·æ±‚
- åˆ†é¡µæŸ¥è¯¢æ”¯æŒå¤§é‡æ•°æ®

---

**è§„åˆ’å®Œæˆæ—¶é—´**: 2025-10-25  
**é¢„è®¡å¼€å‘æ—¶é—´**: 4-6 å°æ—¶  
**ä¼˜å…ˆçº§**: é«˜

