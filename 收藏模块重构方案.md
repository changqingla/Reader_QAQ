# 收藏模块重构方案

## 📋 需求分析

### 核心功能
1. **知识库收藏**
   - 订阅的知识库自动添加到收藏
   - 可以单独收藏未订阅的知识库（如果有查看权限）
   - 取消订阅时，收藏保留（用户可选择是否取消收藏）

2. **文档收藏**
   - 在文档预览页面添加收藏按钮
   - 收藏按钮位置：关闭预览按钮旁边
   - 只能收藏当前能访问的知识库中的文档

3. **收藏展示**
   - 侧边栏 Favorites 页面展示收藏列表
   - 分两个 Tab：收藏的知识库、收藏的文档
   - 支持取消收藏操作

---

## 🗄️ 数据库设计

### 方案：统一收藏表设计

```sql
-- 收藏表（统一管理知识库和文档收藏）
CREATE TABLE favorites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    item_type VARCHAR(20) NOT NULL,  -- 'knowledge_base' 或 'document'
    item_id UUID NOT NULL,           -- 知识库ID或文档ID
    source VARCHAR(20),               -- 'subscription' 表示来自订阅自动收藏，'manual' 表示手动收藏
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- 联合唯一约束：一个用户对同一项目只能收藏一次
    CONSTRAINT uq_user_item UNIQUE (user_id, item_type, item_id)
);

-- 索引优化
CREATE INDEX idx_favorites_user_type ON favorites(user_id, item_type);
CREATE INDEX idx_favorites_created ON favorites(created_at DESC);
```

### 为什么选择统一表？
✅ 优点：
- 简化查询逻辑，一个接口获取所有收藏
- 易于扩展（未来可以收藏其他类型）
- 减少表数量

❌ 缺点：
- 需要关联查询获取详细信息

---

## 🔧 后端实现

### 1. 数据模型

**文件**: `src/models/favorite.py`

```python
"""Favorite database model."""
from sqlalchemy import Column, String, DateTime, ForeignKey, UniqueConstraint, Index
from sqlalchemy.dialects.postgresql import UUID
from config.database import Base
from datetime import datetime
import uuid

class Favorite(Base):
    """Favorite model - unified table for KB and document favorites."""
    __tablename__ = "favorites"
    
    ITEM_TYPE_KB = "knowledge_base"
    ITEM_TYPE_DOC = "document"
    
    SOURCE_SUBSCRIPTION = "subscription"
    SOURCE_MANUAL = "manual"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False, index=True)
    item_type = Column(String(20), nullable=False)  # 'knowledge_base' or 'document'
    item_id = Column(UUID(as_uuid=True), nullable=False)
    source = Column(String(20), nullable=True)  # 'subscription' or 'manual'
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    __table_args__ = (
        UniqueConstraint('user_id', 'item_type', 'item_id', name='uq_user_item_favorite'),
        Index('idx_favorites_user_type', 'user_id', 'item_type'),
    )
    
    def to_dict(self):
        """Convert to dictionary."""
        return {
            "id": str(self.id),
            "userId": str(self.user_id),
            "itemType": self.item_type,
            "itemId": str(self.item_id),
            "source": self.source,
            "createdAt": self.created_at.isoformat(),
        }
```

---

### 2. Repository 层

**文件**: `src/repositories/favorite_repository.py`

```python
"""Favorite repository for database operations."""
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete, func, or_
from sqlalchemy.orm import selectinload
from typing import Optional, List, Tuple
from models.favorite import Favorite
from models.knowledge_base import KnowledgeBase
from models.document import Document
from datetime import datetime

class FavoriteRepository:
    """Repository for Favorite model."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def add_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str,
        source: str = Favorite.SOURCE_MANUAL
    ) -> Favorite:
        """Add a favorite (idempotent)."""
        # Check if already exists
        existing = await self.get_favorite(user_id, item_type, item_id)
        if existing:
            return existing
        
        favorite = Favorite(
            user_id=user_id,
            item_type=item_type,
            item_id=item_id,
            source=source
        )
        self.db.add(favorite)
        await self.db.commit()
        await self.db.refresh(favorite)
        return favorite
    
    async def remove_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> bool:
        """Remove a favorite."""
        result = await self.db.execute(
            delete(Favorite).where(
                Favorite.user_id == user_id,
                Favorite.item_type == item_type,
                Favorite.item_id == item_id
            )
        )
        await self.db.commit()
        return result.rowcount > 0
    
    async def get_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> Optional[Favorite]:
        """Get a specific favorite."""
        result = await self.db.execute(
            select(Favorite).where(
                Favorite.user_id == user_id,
                Favorite.item_type == item_type,
                Favorite.item_id == item_id
            )
        )
        return result.scalar_one_or_none()
    
    async def list_kb_favorites(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[KnowledgeBase], int]:
        """List favorite knowledge bases with details."""
        # Count total
        count_stmt = select(func.count()).select_from(
            select(Favorite)
            .where(
                Favorite.user_id == user_id,
                Favorite.item_type == Favorite.ITEM_TYPE_KB
            )
            .subquery()
        )
        total = (await self.db.execute(count_stmt)).scalar()
        
        # Get favorites with KB details
        stmt = (
            select(KnowledgeBase)
            .join(
                Favorite,
                (Favorite.item_id == KnowledgeBase.id) &
                (Favorite.item_type == Favorite.ITEM_TYPE_KB)
            )
            .where(Favorite.user_id == user_id)
            .order_by(Favorite.created_at.desc())
            .limit(page_size)
            .offset((page - 1) * page_size)
        )
        
        result = await self.db.execute(stmt)
        kbs = result.scalars().all()
        
        return list(kbs), total or 0
    
    async def list_doc_favorites(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[Document], int]:
        """List favorite documents with details."""
        # Count total
        count_stmt = select(func.count()).select_from(
            select(Favorite)
            .where(
                Favorite.user_id == user_id,
                Favorite.item_type == Favorite.ITEM_TYPE_DOC
            )
            .subquery()
        )
        total = (await self.db.execute(count_stmt)).scalar()
        
        # Get favorites with document details
        stmt = (
            select(Document)
            .join(
                Favorite,
                (Favorite.item_id == Document.id) &
                (Favorite.item_type == Favorite.ITEM_TYPE_DOC)
            )
            .where(Favorite.user_id == user_id)
            .order_by(Favorite.created_at.desc())
            .limit(page_size)
            .offset((page - 1) * page_size)
        )
        
        result = await self.db.execute(stmt)
        docs = result.scalars().all()
        
        return list(docs), total or 0
    
    async def check_favorite(
        self,
        user_id: str,
        item_type: str,
        item_id: str
    ) -> bool:
        """Check if an item is favorited."""
        favorite = await self.get_favorite(user_id, item_type, item_id)
        return favorite is not None
```

---

### 3. Service 层

**文件**: `src/services/favorite_service.py`

```python
"""Favorite service business logic."""
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import HTTPException, status
from repositories.favorite_repository import FavoriteRepository
from repositories.kb_repository import KnowledgeBaseRepository
from repositories.document_repository import DocumentRepository
from models.favorite import Favorite
from typing import List, Tuple
import logging

logger = logging.getLogger(__name__)

class FavoriteService:
    """Service for favorite operations."""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.favorite_repo = FavoriteRepository(db)
        self.kb_repo = KnowledgeBaseRepository(db)
        self.doc_repo = DocumentRepository(db)
    
    async def favorite_kb(
        self,
        kb_id: str,
        user_id: str,
        source: str = Favorite.SOURCE_MANUAL
    ) -> dict:
        """Favorite a knowledge base."""
        # Verify KB exists and user has access (owned or public)
        kb = await self.kb_repo.get_by_id(kb_id, user_id)
        if not kb:
            kb = await self.kb_repo.get_by_id_public(kb_id)
            if not kb:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail={"error": {"code": "NOT_FOUND", "message": "Knowledge base not found or not accessible"}}
                )
        
        await self.favorite_repo.add_favorite(
            user_id,
            Favorite.ITEM_TYPE_KB,
            kb_id,
            source
        )
        logger.info(f"User {user_id} favorited KB {kb_id} (source: {source})")
        return {"success": True}
    
    async def unfavorite_kb(self, kb_id: str, user_id: str) -> dict:
        """Unfavorite a knowledge base."""
        success = await self.favorite_repo.remove_favorite(
            user_id,
            Favorite.ITEM_TYPE_KB,
            kb_id
        )
        if success:
            logger.info(f"User {user_id} unfavorited KB {kb_id}")
        return {"success": success}
    
    async def favorite_document(
        self,
        doc_id: str,
        kb_id: str,
        user_id: str
    ) -> dict:
        """Favorite a document."""
        # Verify document exists and user has access to the KB
        kb = await self.kb_repo.get_by_id(kb_id, user_id)
        if not kb:
            kb = await self.kb_repo.get_by_id_public(kb_id)
            if not kb:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail={"error": {"code": "NOT_FOUND", "message": "Knowledge base not found or not accessible"}}
                )
        
        # Verify document exists in this KB
        doc = await self.doc_repo.get_by_id(doc_id, kb_id)
        if not doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail={"error": {"code": "NOT_FOUND", "message": "Document not found"}}
            )
        
        await self.favorite_repo.add_favorite(
            user_id,
            Favorite.ITEM_TYPE_DOC,
            doc_id
        )
        logger.info(f"User {user_id} favorited document {doc_id}")
        return {"success": True}
    
    async def unfavorite_document(self, doc_id: str, user_id: str) -> dict:
        """Unfavorite a document."""
        success = await self.favorite_repo.remove_favorite(
            user_id,
            Favorite.ITEM_TYPE_DOC,
            doc_id
        )
        if success:
            logger.info(f"User {user_id} unfavorited document {doc_id}")
        return {"success": success}
    
    async def list_favorite_kbs(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[dict], int]:
        """List favorite knowledge bases."""
        kbs, total = await self.favorite_repo.list_kb_favorites(user_id, page, page_size)
        return [kb.to_dict(include_owner=True) for kb in kbs], total
    
    async def list_favorite_docs(
        self,
        user_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[dict], int]:
        """List favorite documents with KB info."""
        docs, total = await self.favorite_repo.list_doc_favorites(user_id, page, page_size)
        
        # Enrich with KB info
        result = []
        for doc in docs:
            doc_dict = doc.to_dict()
            # Get KB info
            kb = await self.db.get(KnowledgeBase, doc.kb_id)
            if kb:
                doc_dict["kbName"] = kb.name
                doc_dict["kbAvatar"] = kb.avatar or "/kb.png"
            result.append(doc_dict)
        
        return result, total
    
    async def check_favorites(
        self,
        user_id: str,
        items: List[dict]
    ) -> dict:
        """Batch check if items are favorited."""
        result = {}
        for item in items:
            item_type = item.get("type")
            item_id = item.get("id")
            if item_type and item_id:
                is_favorited = await self.favorite_repo.check_favorite(
                    user_id,
                    item_type,
                    item_id
                )
                result[f"{item_type}:{item_id}"] = is_favorited
        return result
```

---

### 4. Controller 层

**文件**: `src/controllers/favorite_controller.py`

```python
"""Favorite API endpoints."""
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from config.database import get_db
from middlewares.auth import get_current_user
from models.user import User
from services.favorite_service import FavoriteService

router = APIRouter(prefix="/favorites", tags=["Favorites"])

# ============ Knowledge Base Favorites ============

@router.post("/kb/{kbId}")
async def favorite_knowledge_base(
    kbId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Favorite a knowledge base."""
    service = FavoriteService(db)
    return await service.favorite_kb(kbId, str(current_user.id))

@router.delete("/kb/{kbId}")
async def unfavorite_knowledge_base(
    kbId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unfavorite a knowledge base."""
    service = FavoriteService(db)
    return await service.unfavorite_kb(kbId, str(current_user.id))

@router.get("/kb")
async def list_favorite_knowledge_bases(
    page: int = Query(1, ge=1),
    pageSize: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List favorite knowledge bases."""
    service = FavoriteService(db)
    items, total = await service.list_favorite_kbs(str(current_user.id), page, pageSize)
    return {
        "total": total,
        "page": page,
        "pageSize": pageSize,
        "items": items
    }

# ============ Document Favorites ============

@router.post("/document/{docId}")
async def favorite_document(
    docId: str,
    kbId: str = Query(...),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Favorite a document."""
    service = FavoriteService(db)
    return await service.favorite_document(docId, kbId, str(current_user.id))

@router.delete("/document/{docId}")
async def unfavorite_document(
    docId: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Unfavorite a document."""
    service = FavoriteService(db)
    return await service.unfavorite_document(docId, str(current_user.id))

@router.get("/document")
async def list_favorite_documents(
    page: int = Query(1, ge=1),
    pageSize: int = Query(20, ge=1, le=100),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List favorite documents."""
    service = FavoriteService(db)
    items, total = await service.list_favorite_docs(str(current_user.id), page, pageSize)
    return {
        "total": total,
        "page": page,
        "pageSize": pageSize,
        "items": items
    }

# ============ Batch Check ============

@router.post("/check")
async def check_favorites(
    request: dict,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Batch check if items are favorited."""
    service = FavoriteService(db)
    items = request.get("items", [])
    return await service.check_favorites(str(current_user.id), items)
```

---

### 5. 集成到订阅流程

**修改**: `src/services/kb_service.py`

```python
async def subscribe_kb(self, kb_id: str, user_id: str) -> dict:
    """Subscribe to a public knowledge base."""
    # ... existing validation code ...
    
    # Subscribe
    await self.subscription_repo.subscribe(user_id, kb_id)
    logger.info(f"User {user_id} subscribed to KB {kb_id}")
    
    # Auto-favorite when subscribing
    from services.favorite_service import FavoriteService
    favorite_service = FavoriteService(self.db)
    try:
        await favorite_service.favorite_kb(
            kb_id,
            user_id,
            source="subscription"  # Mark as from subscription
        )
    except Exception as e:
        logger.warning(f"Failed to auto-favorite KB {kb_id}: {e}")
    
    # Return updated count
    kb = await self.kb_repo.get_by_id_public(kb_id)
    return {"subscribersCount": kb.subscribers_count}
```

---

## 🎨 前端实现

### 1. API 层

**文件**: `web/lib/api.ts`

```typescript
// 收藏相关 API
export const favoriteAPI = {
  /**
   * 收藏知识库
   */
  async favoriteKB(kbId: string) {
    return request<{ success: boolean }>(`/favorites/kb/${kbId}`, {
      method: 'POST',
    });
  },

  /**
   * 取消收藏知识库
   */
  async unfavoriteKB(kbId: string) {
    return request<{ success: boolean }>(`/favorites/kb/${kbId}`, {
      method: 'DELETE',
    });
  },

  /**
   * 获取收藏的知识库列表
   */
  async listFavoriteKBs(page: number = 1, pageSize: number = 20) {
    const params = new URLSearchParams({ page: page.toString(), pageSize: pageSize.toString() });
    return request<{ total: number; page: number; pageSize: number; items: any[] }>(
      `/favorites/kb?${params}`,
      { method: 'GET' }
    );
  },

  /**
   * 收藏文档
   */
  async favoriteDocument(docId: string, kbId: string) {
    const params = new URLSearchParams({ kbId });
    return request<{ success: boolean }>(`/favorites/document/${docId}?${params}`, {
      method: 'POST',
    });
  },

  /**
   * 取消收藏文档
   */
  async unfavoriteDocument(docId: string) {
    return request<{ success: boolean }>(`/favorites/document/${docId}`, {
      method: 'DELETE',
    });
  },

  /**
   * 获取收藏的文档列表
   */
  async listFavoriteDocuments(page: number = 1, pageSize: number = 20) {
    const params = new URLSearchParams({ page: page.toString(), pageSize: pageSize.toString() });
    return request<{ total: number; page: number; pageSize: number; items: any[] }>(
      `/favorites/document?${params}`,
      { method: 'GET' }
    );
  },

  /**
   * 批量检查收藏状态
   */
  async checkFavorites(items: Array<{ type: string; id: string }>) {
    return request<{ [key: string]: boolean }>('/favorites/check', {
      method: 'POST',
      body: JSON.stringify({ items }),
    });
  },
};
```

---

### 2. Favorites 页面重构

**文件**: `web/pages/Favorites.tsx`

```typescript
import React, { useState, useEffect } from 'react';
import { Database, FileText, Trash2 } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import Sidebar from '@/components/Sidebar/Sidebar';
import { favoriteAPI } from '@/lib/api';
import { useToast } from '@/hooks/useToast';
import styles from './Favorites.module.css';

type TabType = 'kb' | 'doc';

export default function Favorites() {
  const navigate = useNavigate();
  const toast = useToast();
  const [activeTab, setActiveTab] = useState<TabType>('kb');
  const [favoriteKBs, setFavoriteKBs] = useState<any[]>([]);
  const [favoriteDocs, setFavoriteDocs] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadFavorites();
  }, [activeTab]);

  const loadFavorites = async () => {
    setLoading(true);
    try {
      if (activeTab === 'kb') {
        const response = await favoriteAPI.listFavoriteKBs();
        setFavoriteKBs(response.items);
      } else {
        const response = await favoriteAPI.listFavoriteDocuments();
        setFavoriteDocs(response.items);
      }
    } catch (error) {
      console.error('Failed to load favorites:', error);
      toast.error('加载收藏失败');
    } finally {
      setLoading(false);
    }
  };

  const handleUnfavoriteKB = async (kbId: string) => {
    try {
      await favoriteAPI.unfavoriteKB(kbId);
      toast.success('已取消收藏');
      loadFavorites();
    } catch (error: any) {
      toast.error(error.message || '操作失败');
    }
  };

  const handleUnfavoriteDoc = async (docId: string) => {
    try {
      await favoriteAPI.unfavoriteDocument(docId);
      toast.success('已取消收藏');
      loadFavorites();
    } catch (error: any) {
      toast.error(error.message || '操作失败');
    }
  };

  return (
    <div className={styles.page}>
      <Sidebar />
      
      <div className={styles.main}>
        <h1 className={styles.title}>我的收藏</h1>

        <div className={styles.tabs}>
          <button
            className={`${styles.tab} ${activeTab === 'kb' ? styles.tabActive : ''}`}
            onClick={() => setActiveTab('kb')}
          >
            <Database size={16} />
            收藏的知识库
          </button>
          <button
            className={`${styles.tab} ${activeTab === 'doc' ? styles.tabActive : ''}`}
            onClick={() => setActiveTab('doc')}
          >
            <FileText size={16} />
            收藏的文档
          </button>
        </div>

        {loading ? (
          <div className={styles.loading}>加载中...</div>
        ) : (
          <div className={styles.content}>
            {activeTab === 'kb' ? (
              favoriteKBs.length === 0 ? (
                <div className={styles.empty}>
                  <Database size={48} />
                  <p>还没有收藏任何知识库</p>
                </div>
              ) : (
                <div className={styles.grid}>
                  {favoriteKBs.map((kb) => (
                    <div key={kb.id} className={styles.card}>
                      <img src={kb.avatar} alt={kb.name} className={styles.avatar} />
                      <div className={styles.cardBody}>
                        <h3 className={styles.cardTitle}>{kb.name}</h3>
                        <p className={styles.cardDesc}>{kb.description || '暂无描述'}</p>
                        <div className={styles.cardActions}>
                          <button
                            className={styles.btnView}
                            onClick={() => navigate(`/knowledge/${kb.id}`)}
                          >
                            查看
                          </button>
                          <button
                            className={styles.btnDelete}
                            onClick={() => handleUnfavoriteKB(kb.id)}
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )
            ) : (
              favoriteDocs.length === 0 ? (
                <div className={styles.empty}>
                  <FileText size={48} />
                  <p>还没有收藏任何文档</p>
                </div>
              ) : (
                <div className={styles.list}>
                  {favoriteDocs.map((doc) => (
                    <div key={doc.id} className={styles.docItem}>
                      <FileText size={20} />
                      <div className={styles.docInfo}>
                        <div className={styles.docName}>{doc.name}</div>
                        <div className={styles.docKb}>来自: {doc.kbName}</div>
                      </div>
                      <button
                        className={styles.btnDelete}
                        onClick={() => handleUnfavoriteDoc(doc.id)}
                      >
                        <Trash2 size={14} />
                      </button>
                    </div>
                  ))}
                </div>
              )
            )}
          </div>
        )}
      </div>
    </div>
  );
}
```

---

### 3. 文档预览页面添加收藏按钮

**修改**: `web/pages/KnowledgeDetail.tsx`

在文档预览区域添加收藏按钮（关闭预览按钮旁边）：

```typescript
<div className={styles.previewHeader}>
  <FileText size={18} />
  <span className={styles.previewTitle}>{selectedDoc.name}</span>
  <div className={styles.previewActions}>
    <button
      className={`${styles.iconBtn} ${docIsFavorited ? styles.favorited : ''}`}
      onClick={handleToggleFavoriteDoc}
      title={docIsFavorited ? '取消收藏' : '收藏文档'}
    >
      <Star size={16} fill={docIsFavorited ? 'currentColor' : 'none'} />
    </button>
    <button
      className={styles.iconBtn}
      onClick={() => setSelectedDoc(null)}
      title="关闭预览"
    >
      <X size={18} />
    </button>
  </div>
</div>
```

---

## 📊 数据流程图

```
┌─────────────────────────────────────────┐
│         用户订阅知识库                    │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│  1. 创建订阅记录 (kb_subscriptions)      │
│  2. subscribers_count += 1              │
│  3. 自动创建收藏记录 (favorites)         │
│     - source: "subscription"            │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│         用户取消订阅                      │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│  1. 删除订阅记录                         │
│  2. subscribers_count -= 1              │
│  3. 收藏记录保留 (用户可手动删除)         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│         用户收藏文档                      │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│  1. 验证用户对KB有访问权限                │
│  2. 验证文档存在                         │
│  3. 创建收藏记录                         │
└─────────────────────────────────────────┘
```

---

## ✅ 实现检查清单

### 后端 Backend
- [ ] 创建 `src/models/favorite.py`
- [ ] 创建 `src/repositories/favorite_repository.py`
- [ ] 创建 `src/services/favorite_service.py`
- [ ] 创建 `src/controllers/favorite_controller.py`
- [ ] 在 `main.py` 中注册 favorite_controller
- [ ] 修改 `src/services/kb_service.py` - 订阅时自动收藏
- [ ] 创建数据库迁移脚本
- [ ] 测试所有 API 端点

### 前端 Frontend
- [ ] 在 `web/lib/api.ts` 中添加 favoriteAPI
- [ ] 重构 `web/pages/Favorites.tsx`
- [ ] 创建 `web/pages/Favorites.module.css`
- [ ] 在 `web/pages/KnowledgeDetail.tsx` 添加文档收藏按钮
- [ ] 添加收藏状态管理（useState）
- [ ] 添加收藏/取消收藏交互
- [ ] 测试用户交互流程

### 数据库 Database
- [ ] 创建 `favorites` 表
- [ ] 添加索引优化
- [ ] 数据迁移测试

---

## 🎯 优势总结

### ✅ 用户体验
- 订阅知识库自动收藏，减少操作步骤
- 文档收藏方便快速访问
- 统一的收藏管理界面

### ✅ 技术优势
- 统一表设计，易于扩展
- 幂等性保证，重复操作无副作用
- 完整的权限校验，安全可靠

### ✅ 性能优化
- 合理的索引设计
- 批量检查接口减少请求
- 分页查询支持大量数据

---

**规划完成时间**: 2025-10-25  
**预计开发时间**: 4-6 小时  
**优先级**: 高

